#pragma once

#include "${{MachineName}}.h"

namespace ${{MachineName}} {
	const std::shared_ptr<RawStreamLocation>& Production::location() const {
		return m_location;
	}

	std::shared_ptr<Terminal> ${{MachineName}}::apply(RawStream& rs) {
		struct BranchingPoint {
			size_t inputPosition;
			size_t actionStackPosition;
			std::vector<State> remainingStates;
			std::vector<ActionMethodPointer> remainingActions;

			BranchingPoint(size_t inputPosition,
					size_t actionStackPosition,
					const std::vector<State>& remainingStates,
					const std::vector<ActionMethodPointer>& remainingActions)
				: inputPosition(inputPosition), actionStackPosition(actionStackPosition),
				remainingStates(remainingStates), remainingActions(remainingActions) { }
		};

		struct ActionPack {
			ActionMethodPointer action;
			size_t position;
			std::shared_ptr<RawStreamLocation> location;

			ActionPack()
				: action(nullptr), position((size_t)-1), location(nullptr) { }

			ActionPack(ActionMethodPointer action, size_t position, const std::shared_ptr<RawStreamLocation>& location)
				: action(action), position(position), location(location) { }
		};

		const std::vector<State> emptyStateVector;
		const std::vector<ActionMethodPointer> emptyActionVector;
		std::shared_ptr<Terminal> tokenToReturn = nullptr;
		
		State lastAcceptingState = (State)(-1);
		size_t lastAcceptedInputPosition = 0;
		size_t lastAcceptedActionStackPosition = 0;
		std::list<BranchingPoint> branchingPoints;
		std::vector<ActionPack> actionStack;

		// register the actions associated with state 0 if there are any
		if(this->m_stateActions[0] != nullptr) {
			actionStack.emplace_back(this->m_stateActions[0], rs.currentPosition(), rs.currentLocation());
		}

		rs.pin();
		while (true) {
			char currentCharacter;
			bool readingOutcome = rs.get(currentCharacter);
			const std::vector<State>& nextStates = !readingOutcome ? emptyStateVector : m_stateMap[m_currentState][currentCharacter];
			const std::vector<ActionMethodPointer>& nextActions = !readingOutcome ? emptyActionVector : this->m_transitionActions[m_currentState][currentCharacter];

			State stateToGoTo;
			ActionMethodPointer stateToGoToCorrespondingTransitionAction = nullptr;
			if(nextStates.empty()) {
				if(!branchingPoints.empty()) {
					BranchingPoint& lastBp = branchingPoints.back();
					rs.resetToPosition(lastBp.inputPosition);
					stateToGoTo = lastBp.remainingStates.back();
					stateToGoToCorrespondingTransitionAction = lastBp.remainingActions.back();
					lastBp.remainingStates.pop_back();
					lastBp.remainingActions.pop_back();
					actionStack.resize(lastBp.actionStackPosition);
					
					if(lastBp.remainingStates.empty()) {
						branchingPoints.pop_back();
					}
				} else {
					if (lastAcceptingState == (State)(-1)) {
						if (m_currentState > 0) {
							// failure, we are not in the first state and we have not reached any accepting state so far, so we will return nullptr. The users are then encouraged to make use of lastApplicationSuccessful() and RawStream location information to identify the issue
							// the stream is left as we left it after the last read, it is up to user to try to rs.resetToPin() and try again if they want to
							// further, rawSincePin() gives precisely the token that we failed to match
							break;
						} else {
							// all done, lastApplicationSuccessful!
							break;
						}
					} else {
						// accept, reset m_currentState to 0, and backtrack input to where the lastAcceptingState was hit
						m_currentState = 0;
						rs.resetToPosition(lastAcceptedInputPosition);
						std::string completeRaw = rs.rawSincePin();

						// execute all actions leading up to this position
						for(size_t i = 0;i < lastAcceptedActionStackPosition;++i) {
							const ActionPack& actionPackObject = actionStack[i];
							(this->*actionPackObject.action)(actionPackObject.position, completeRaw, actionPackObject.location);
						}

						// plan to return the built token
						tokenToReturn = m_token;

						// pin the input stream forward
						rs.pin(); // that is, at lastAcceptedPosition, not at the position at which we entered this else clause
						
						// break out of this loop and proceed
						break;
					}
				}
			} else if(nextStates.size() == 1) {
				stateToGoTo = nextStates.front();
				stateToGoToCorrespondingTransitionAction = nextActions.front();
			} else {
				branchingPoints.emplace_back(rs.currentPosition(), actionStack.size(), nextStates, nextActions);
				BranchingPoint& lastBp = branchingPoints.back();
				stateToGoTo = lastBp.remainingStates.back();
				lastBp.remainingStates.pop_back();
				stateToGoToCorrespondingTransitionAction = lastBp.remainingActions.back();
				lastBp.remainingActions.pop_back();
			}

			// register the state actions, but only if an actual changing transition occurs
			if(stateToGoTo != m_currentState && this->m_stateActions[stateToGoTo] != nullptr) {
				actionStack.emplace_back(this->m_stateActions[stateToGoTo], rs.currentPosition(), rs.currentLocation());
			}

			// register transition actions
			if(stateToGoToCorrespondingTransitionAction != nullptr) {
				actionStack.emplace_back(stateToGoToCorrespondingTransitionAction, rs.currentPosition(), rs.currentLocation());
			}

			// if this is a final state and strictly longer than the previous accepted sequence, take a note of that
			if (m_stateFinality[stateToGoTo] && rs.currentPosition() > lastAcceptedInputPosition) {
				lastAcceptingState = stateToGoTo;
				lastAcceptedInputPosition = rs.currentPosition();
				lastAcceptedActionStackPosition = actionStack.size();
			}

			// finally, change the state
			m_currentState = stateToGoTo;
		}

		m_token = nullptr;
		return tokenToReturn;
	}

	std::list<std::shared_ptr<Terminal>> ${{MachineName}}::process(RawStream& rs) {
		std::list<std::shared_ptr<Terminal>> ret;

		while (lastApplicationSuccessful() && rs.good()) {
			auto terminalPtr = apply(rs);
			if (terminalPtr) {
				ret.push_back(terminalPtr);
			}
		}

		if (lastApplicationSuccessful()) {
			auto eosLocationPtr = rs.pinLocation()->clone();
			eosLocationPtr->advance();
			ret.push_back(std::make_shared<EOS>(eosLocationPtr));
		}

		return ret;
	}

	void ${{MachineName}}::reset() {
		m_currentState = 0;
	}

	std::vector<State> ${{MachineName}}::m_stateMap[${{StateCount}}][${{TransitionCount}}] = {
		${{StateMapEnumerated}} 
	};
	bool ${{MachineName}}::m_stateFinality[${{StateCount}}] = { 
		${{StateFinalityEnumerated}} 
	};
	std::vector<ActionMethodPointer> ${{MachineName}}::m_transitionActions[${{StateCount}}][${{TransitionCount}}] = {
		${{TransitionActionMapEnumerated}}
	};
	ActionMethodPointer ${{MachineName}}::m_stateActions[${{StateCount}}] = {
		${{StateActionMapEnumerated}}
	};

	${{ActionDefinitions}}
}
