#pragma once

#include "${{MachineName}}.h"

namespace ${{MachineName}} {
	const std::shared_ptr<RawStreamLocation>& Production::location() const {
		return m_location;
	}

	std::shared_ptr<Terminal> ${{MachineName}}::apply(RawStream& rs) {
		struct BranchingPoint {
			size_t inputPosition;
			size_t actionStackPosition;
			std::vector<State> remainingStates;
			std::vector<(${{MachineName}}::*)(char)> remainingActions;

			BranchingPoint(size_t inputPosition,
					size_t actionStackPosition,
					const std::vector<State>& remainingStates,
					const std::vector<(${{MachineName}}::*)(char)>& remainingActions)
				: inputPosition(inputPosition), actionStackPosition(actionStackPosition),
				remainingStates(remainingStates), remainingActions(remainingActions) { }
		};

		struct ActionPack {
			(${{MachineName}}::* action)(char);
			char payload;

			ActionPack((${{MachineName}}::* action)(char), char payload)
				: action(action), payload(payload) { }
		};

		const std::vector<State> emptyStateVector;
		const std::vector<(${{MachineName}}::*)(char)> emptyActionVector;
		std::shared_ptr<Terminal> tokenToReturn = nullptr;
		
		std::list<BranchingPoint> branchingPoints;
		State lastAcceptingState = (State)(-1);
		size_t lastAcceptedInputPosition = 0;
		size_t lastAcceptedActionStackPosition = 0;
		std::vector<ActionPack> actionStack;

		// register the actions associated with state 0 if there are any
		if(this->m_stateActions[0] != nullptr) {
			actionStack.emplace_back(this->m_stateActions[0], '\0');
		}

		rs.pin();
		while (true) {
			char currentCharacter;
			bool readingOutcome = rs.get(currentCharacter);
			const std::vector<State>& nextStates = !readingOutcome ? emptyStateVector : m_stateMap[m_currentState][currentCharacter];
			const std::vector<(${{MachineName}}::*)(char)>& nextActions = !readingOutcome ? emptyActionVector : this->m_transitionActions[m_currentState][currentCharacter];

			State stateToGoTo;
			(${{MachineName}}::* stateToGoToCorrespondingTransitionAction)(char);
			if(nextStates.empty()) {
				if(!branchingPoints.empty()) {
					BranchingPoint& lastBp = branchingPoints.back();
					rs.revertTo(lastBp.inputPosition);
					stateToGoTo = lastBp.remainingStates.back();
					stateToGoToCorrespondingTransitionAction = lastBp.remainingActions.back();
					lastBp.remainingStates.pop_back();
					stateToGoToCorrespondingTransitionAction.remainingActions.pop_back();
					actionStack.resize(lastBp.actionStackPosition);
					
					if(lastBp.remainingStates.empty()) {
						branchingPoints.pop_back();
					}
				} else {
					if (lastAcceptingState == (State)(-1)) {
						if (m_currentState > 0) {
							// failure, we are not in the first state and we have not reached any accepting state so far, so we will return nullptr. The users are then encouraged to make use of lastApplicationSuccessful() and RawStream location information to identify the issue
							break;
						} else {
							// all done, lastApplicationSuccessful!
							break;
						}
					} else {
						// accept, reset m_currentState to 0, and backtrack input to where the lastAcceptingState was hit
						m_currentState = 0;
						rs.resetToPosition(lastAcceptedPosition);

						// execute all actions leading up to this position
						for(size_t i = 0;i < lastAcceptedActionStackPosition;++i) {
							const ActionPack& actionPackObject = actionStack[i];
							actionPackObject.action(actionPackObject.payload);
						}

						// plan to return the built token
						tokenToReturn = m_token;

						// pin the input stream forward
						rs.pin();
						
						// break out of this loop and proceed
						break;
					}
				}
			} else if(nextStates.size() == 1) {
				stateToGoTo = nextStates.front();
				stateToGoToCorrespondingTransitionAction = nextActions.front();
			} else {
				branchingPoints.emplace_back(rs.currentPosition(), actionStack.size(), nextStates, nextActions);
				BranchingPoint& lastBp = branchingPoints.back();
				stateToGoTo = lastBp.remainingStates.back();
				lastBp.remainingStates.pop_back();
				stateToGoToCorrespondingTransitionAction = lastBp.remainingActions.back();
				lastBp.remainingActions.pop_back();
			}

			// register the state actions, but only if an actual changing transition occurs
			if(stateToGoTo != m_currentState && this->m_stateActions[stateToGoTo] != nullptr) {
				actionStack.emplace_back(this->m_stateActions[stateToGoTo], '\0');
			}

			// if this is a final state and strictly longer than the previous accepted sequence, take a note of that
			if (m_stateFinality[stateToGoTo] && rs.currentPosition() > lastAcceptedPosition) {
				lastAcceptingState = stateToGoTo;
				lastAcceptedPosition = rs.currentPosition();
				lastAcceptedActionStackPosition = actionStack.size();
			}

			// finally, change the state
			m_currentState = stateToGoTo;
		}

		m_token = nullptr;
		return tokenToReturn;
	}

	std::list<std::shared_ptr<Terminal>> ${{MachineName}}::process(RawStream& rs) {
		std::list<std::shared_ptr<Terminal>> ret;

		while (lastApplicationSuccessful() && rs.good()) {
			auto terminalPtr = apply(rs);
			if (terminalPtr) {
				ret.push_back(terminalPtr);
			}
		}

		if (lastApplicationSuccessful()) {
			auto eosLocationPtr = rs.pinLocation()->clone();
			eosLocationPtr->advance();
			ret.push_back(std::make_shared<EOS>(eosLocationPtr));
		}

		return ret;
	}

	void ${{MachineName}}::reset() {
		m_currentState = 0;
	}

	std::vector<State> ${{MachineName}}::m_stateMap[${{StateCount}}][${{TransitionCount}}] = {
		${{StateMapEnumerated}} 
	};
	bool ${{MachineName}}::m_stateFinality[${{StateCount}}] = { 
		${{StateFinalityEnumerated}} 
	};
	void std::vector<(${{MachineName}}::*)(char)> ${{MachineName}}::m_transitionActions[${{StateCount}}][${{TransitionCount}}] = {
		${{TransitionActionMapEnumerated}}
	};
	void (${{MachineName}}::* ${{MachineName}}::m_stateActions[${{StateCount}}])() = {
		${{StateActionMapEnumerated}}
	};

	${{ActionDefinitions}}
}
