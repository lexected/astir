#pragma once

#include "${{MachineName}}.h"

namespace ${{MachineName}} {
	const std::shared_ptr<RawStreamLocation>& Production::location() const {
		return m_location;
	}

	std::shared_ptr<Terminal> ${{MachineName}}::apply(RawStream& rs) {
		char currentCharacter;
		State lastAcceptingState = (State)(-1);
		std::shared_ptr<Terminal> tokenToReturn = nullptr;

		if(this->m_stateActions[0] != nullptr) {
			(this->*m_stateActions[0])(rs);
		}

		rs.pin();
		while (true) {
			State stateToGoTo;
			if (!rs.get(currentCharacter)) {
				stateToGoTo = (State)(-1);
			} else {
				stateToGoTo = m_stateMap[m_currentState][currentCharacter];
			}

			if (stateToGoTo == (State)(-1)) {
				if (lastAcceptingState == (State)(-1)) {
					if (m_currentState > 0) {
						// failure, we are not in the first state and we have not reached any accepting state so far, so we will return nullptr. The users are then encouraged to make use of lastApplicationSuccessful() and RawStream location information to identify the issue
						break;
					} else {
						// all done, lastApplicationSuccessful!
						break;
					}
				} else {
					// accept, reset m_currentState to 0, and backtrack input to where the lastAcceptingState was hit
					m_currentState = 0;
					rs.resetToPin();
					tokenToReturn = m_token;
					break;
				}
			} else {
				// execute the transition actions
				if(this->m_transitionActions[m_currentState][currentCharacter] != nullptr) {
					(this->*m_transitionActions[m_currentState][currentCharacter])(currentCharacter);
				}

				// execute the state actions, but only if a transition occurs
				if(stateToGoTo != m_currentState && this->m_stateActions[stateToGoTo] != nullptr) {
					(this->*m_stateActions[stateToGoTo])(rs);
				}

				// if this is a final state, take a note of that
				if (m_stateFinality[stateToGoTo]) {
					lastAcceptingState = stateToGoTo;
					rs.pin();
				}

				// and finally, change the current state to the new state
				m_currentState = stateToGoTo;
			}
		}

		m_token = nullptr;
		return tokenToReturn;
	}

	std::list<std::shared_ptr<Terminal>> ${{MachineName}}::process(RawStream& rs) {
		std::list<std::shared_ptr<Terminal>> ret;

		while (lastApplicationSuccessful() && rs.good()) {
			auto terminalPtr = apply(rs);
			if (terminalPtr) {
				ret.push_back(terminalPtr);
			}
		}

		if (lastApplicationSuccessful()) {
			auto eosLocationPtr = rs.pinLocation()->clone();
			eosLocationPtr->advance();
			ret.push_back(std::make_shared<EOS>(eosLocationPtr));
		}

		return ret;
	}

	void ${{MachineName}}::reset() {
		m_currentState = 0;
	}

	State ${{MachineName}}::m_stateMap[${{StateCount}}][${{TransitionCount}}] = {
		${{StateMapEnumerated}} 
	};
	bool ${{MachineName}}::m_stateFinality[${{StateCount}}] = { 
		${{StateFinalityEnumerated}} 
	};
	void (${{MachineName}}::* ${{MachineName}}::m_transitionActions[${{StateCount}}][${{TransitionCount}}])(char c) = {
		${{TransitionActionMapEnumerated}}
	};
	void (${{MachineName}}::* ${{MachineName}}::m_stateActions[${{StateCount}}])(const RawStream& stream) = {
		${{StateActionMapEnumerated}}
	};

	${{ActionDefinitions}}
}
