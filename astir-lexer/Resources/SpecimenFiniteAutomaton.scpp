#pragma once

#include "${{MachineName}}.h"

namespace ${{MachineName}} {
	const std::shared_ptr<RawStreamLocation>& Production::location() const {
		return m_location;
	}

	std::shared_ptr<Terminal> ${{MachineName}}::apply(RawStream& rs) {
		struct BranchingPoint {
			size_t inputPosition;
			size_t actionStackPosition;
			std::vector<State> remainingStates;
			std::vector<ActionMethodPointer> remainingActions;

			BranchingPoint(size_t inputPosition,
					size_t actionStackPosition,
					const std::vector<State>& remainingStates,
					const std::vector<ActionMethodPointer>& remainingActions)
				: inputPosition(inputPosition), actionStackPosition(actionStackPosition),
				remainingStates(remainingStates), remainingActions(remainingActions) { }
		};

		struct ActionPack {
			ActionMethodPointer action;
			size_t position;
			std::shared_ptr<RawStreamLocation> location;

			ActionPack()
				: action(nullptr), position((size_t)-1), location(nullptr) { }
			ActionPack(ActionMethodPointer action, size_t position, const std::shared_ptr<RawStreamLocation>& location)
				: action(action), position(position), location(location) { }
		};

		const std::vector<State> emptyStateVector;
		const std::vector<ActionMethodPointer> emptyActionVector;
		std::shared_ptr<Terminal> tokenToReturn = nullptr;
		
		State lastAcceptingState = (State)(-1);
		size_t lastAcceptedInputPosition = 0;
		std::vector<ActionPack> lastAcceptedActionStack;
		std::list<BranchingPoint> branchingPoints;
		std::vector<ActionPack> actionStack;

		m_currentState = 0;
		rs.pin();

		// register the actions associated with state 0 if there are any
		if(this->m_stateActions[0] != nullptr) {
			actionStack.emplace_back(this->m_stateActions[0], rs.currentPosition(), rs.currentLocation());
		}
		
		while (true) {
			char currentCharacter;
			auto currentPosition = rs.currentPosition();
			auto currentLocation = rs.currentLocation();
			bool readingOutcome = rs.get(currentCharacter);
			const std::vector<State>& nextStates = !readingOutcome ? emptyStateVector : m_stateMap[m_currentState][currentCharacter];
			const std::vector<ActionMethodPointer>& nextActions = !readingOutcome ? emptyActionVector : this->m_transitionActions[m_currentState][currentCharacter];

			State stateToGoTo;
			ActionMethodPointer stateToGoToCorrespondingTransitionAction = nullptr;
			if(nextStates.empty()) {
				if(!branchingPoints.empty()) {
					BranchingPoint& lastBp = branchingPoints.back();
					// simulate reading of the character at which we branched again
					currentPosition = lastBp.inputPosition;
					rs.resetToPosition(lastBp.inputPosition);
					currentLocation = rs.currentLocation();
					readingOutcome = rs.get(currentCharacter);
					
					stateToGoTo = lastBp.remainingStates.back();
					lastBp.remainingStates.pop_back();

					stateToGoToCorrespondingTransitionAction = lastBp.remainingActions.back();
					lastBp.remainingActions.pop_back();
					actionStack.resize(lastBp.actionStackPosition);
					
					if(lastBp.remainingStates.empty()) {
						branchingPoints.pop_back();
					}
				} else {
					if (lastAcceptingState == (State)(-1)) {
						// in case of failure at this point, we are not in the first state and we have not reached any accepting state so far, so we will return nullptr. The users are then encouraged to make use of lastApplicationSuccessful() and RawStream location information to identify the issue
						// the stream is left as we left it after the last read, it is up to user to try to rs.resetToPin() and try again if they want to
						// further, rawSincePin() gives precisely the token that we failed to match

						// but you can also reach this point by simply reaching an accepting state and not being able to proceed any further
						break;
					} else {
						// backtrack input to where the lastAcceptingState was hit
						rs.resetToPosition(lastAcceptedInputPosition);
						std::string completeRaw = rs.rawSincePin();

						// execute all actions accepted with the state
						for(const ActionPack& actionPackObject : lastAcceptedActionStack) {
							(this->*actionPackObject.action)(actionPackObject.position, completeRaw, actionPackObject.location);
						}

						// plan to return the built token
						tokenToReturn = m_token;

						// pin the input stream forward
						rs.pin(); // that is, at lastAcceptedPosition, not at the position at which we entered this else clause
						
						// break out of this loop and proceed
						break;
					}
				}
			} else if(nextStates.size() == 1) {
				stateToGoTo = nextStates.front();
				stateToGoToCorrespondingTransitionAction = nextActions.front();
			} else {
				branchingPoints.emplace_back(currentPosition, actionStack.size(), nextStates, nextActions);
				BranchingPoint& lastBp = branchingPoints.back();
				stateToGoTo = lastBp.remainingStates.back();
				lastBp.remainingStates.pop_back();
				stateToGoToCorrespondingTransitionAction = lastBp.remainingActions.back();
				lastBp.remainingActions.pop_back();
			}

			// register transition actions
			// this must happen before the registration of state actions!
			if(stateToGoToCorrespondingTransitionAction != nullptr) {
				actionStack.emplace_back(stateToGoToCorrespondingTransitionAction, currentPosition, currentLocation);
			}

			// register the state actions
			// this must happen after the registration of transition actions!
			if(this->m_stateActions[stateToGoTo] != nullptr) {
				actionStack.emplace_back(this->m_stateActions[stateToGoTo], currentPosition, currentLocation);
			}

			// if this is a final state and strictly longer than the previous accepted sequence, take a note of that
			if (m_stateFinality[stateToGoTo] && rs.currentPosition() > lastAcceptedInputPosition) {
				// remember, rs.currentPosition() is of currentPosition by 1, and it is the right quantity to use here
				lastAcceptingState = stateToGoTo;
				lastAcceptedInputPosition = rs.currentPosition();
				lastAcceptedActionStack = actionStack;
			}

			// finally, change the state
			m_currentState = stateToGoTo;
		}

		m_token = nullptr;
		return tokenToReturn;
	}

	std::list<std::shared_ptr<Terminal>> ${{MachineName}}::process(RawStream& rs) {
		std::list<std::shared_ptr<Terminal>> ret;

		while (lastApplicationSuccessful() && rs.good()) {
			auto terminalPtr = apply(rs);
			if (terminalPtr) {
				ret.push_back(terminalPtr);
			}
		}

		if (lastApplicationSuccessful()) {
			auto eosLocationPtr = rs.pinLocation()->clone();
			eosLocationPtr->advance();
			ret.push_back(std::make_shared<EOS>(eosLocationPtr));
		}

		return ret;
	}

	void ${{MachineName}}::reset() {
		m_currentState = 0;
	}

	std::vector<State> ${{MachineName}}::m_stateMap[${{StateCount}}][${{TransitionCount}}] = {
		${{StateMapEnumerated}} 
	};
	bool ${{MachineName}}::m_stateFinality[${{StateCount}}] = { 
		${{StateFinalityEnumerated}} 
	};
	std::vector<ActionMethodPointer> ${{MachineName}}::m_transitionActions[${{StateCount}}][${{TransitionCount}}] = {
		${{TransitionActionMapEnumerated}}
	};
	ActionMethodPointer ${{MachineName}}::m_stateActions[${{StateCount}}] = {
		${{StateActionMapEnumerated}}
	};

	${{ActionDefinitions}}
}
