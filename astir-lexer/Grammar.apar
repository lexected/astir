/*
	RECOGNIZED TOKENS:
		KW_USING
		KW_TOKEN
		KW_REGEX
		KW_PRODUCTION
		KW_RULE
		KW_DETERMINISTIC
		KW_NONDETERMINISTIC
		KW_FINITE
		KW_AUTOMATON
		KW_PARSER
		KW_RECURSIVE_DESCENT
		KW_WITH
		KW_FOLLOWS
		KW_EXTENDS
		KW_INDIVIDUAL_STRING_LITERALS
		KW_GROUPED_STRING_LITERALS
		KW_TABLE_LOOKUP
		KW_MACHINE_LOOKUP
		KW_BACKTRACKING
		KW_PREDICTION
		KW_CATEGORY

		KW_SET
		KW_UNSET
		KW_FLAG
		KW_UNFLAG
		KW_APPEND
		KW_PREPEND
		KW_CLEAR
		KW_LEFT_TRIM
		KW_RIGHT_TRIM

		IDENTIFIER
		NUMBER
		STRING

		OP_EQUALS
		OP_COLON
		OP_LEFTARR
		OP_SEMICOLON
		OP_DOT
		OP_CARET
		OP_DOLLAR
		SQUARE_LEFT
		SQUARE_RIGHT
		PAR_LEFT
		PAR_RIGHT
		CURLY_LEFT
		CURLY_RIGHT
		OP_STAR
		OP_PLUS
		OP_QM
		OP_OR
		OP_FWDSLASH,
		OP_COMMA,
		OP_AT
*/

production specification = 
	specificationStatement*
	;

production specificationStatement =
	machineDefinition
	| usingStatement
	;

production usingStatement =
	KW_USING STRING
	;

production machineDefinition =
	machineType IDENTIFIER (KW_WITH machineOptionList)? (KW_EXTENDS IDENTIFIER| KW_FOLLOWS IDENTIFIER)? OP_SEMICOLON
	| machineType IDENTIFIER (KW_WITH machineOptionList)? (KW_EXTENDS IDENTIFIER| KW_FOLLOWS IDENTIFIER)? CURLY_LEFT machineDefinitionBody CURLY_RIGHT
	;

rule machineOptionList =
	(KW_INDIVIDUAL_STRING_LITERALS
		| KW_GROUPED_STRING_LITERALS
		| KW_TABLE_LOOKUP
		| KW_MACHINE_LOOKUP
		| KW_BACKTRACKING
		| KW_PREDICTION)+
	;

production machineDefinitionBody =
	statementList
	;

rule statementList =
	statement*
	;

production statement =
	categoryStatement
	| grammarStatement
	;

production categoryStatement =
	KW_CATEGORY IDENTIFIER OP_EQUALS categoryStatementBody OP_SEMICOLON
	| KW_CATEGORY IDENTIFIER OP_COLON declarationNameList OP_EQUALS categoryStatementBody OP_SEMICOLON
	| KW_CATEGORY IDENTIFIER OP_COLON declarationNameList OP_SEMICOLON
	| KW_CATEGORY IDENTIFIER OP_SEMICOLON
	;

rule categoryStatementBody =
	qualifiedName*
	;

production qualifiedName =
	specifiedName OP_AT KW_ITEM OP_COLON identifier
	| specifiedName OP_AT KW_LIST OP_COLON identifier
	| specifiedName OP_AT KW_FLAG OP_COLON identifier
	;

production grammarStatement =
	grammarStatementType IDENTIFIER OP_EQUALS grammarStatementBody OP_SEMICOLON
	| grammarStatementType IDENTIFIER OP_COLON declarationNameList OP_EQUALS grammarStatementBody OP_SEMICOLON
	;

rule grammarStatementType =
	KW_TOKEN
	| KW_REGEX
	| KW_RULE
	| KW_PRODUCTION
	;

rule declarationNameList =
	IDENTIFIER OP_COMMA declarationNameList
	| IDENTIFIER
	;

production grammarStatementBody = 
	alternative*
	;

production alternative = 
	rootRegex*
	;

production rootRegex =
	repetitiveRegex
	| lookaheadRegex
	| actionAtomicRegex
	;

production repetitiveRegex =
	actionAtomicRegex OP_QM
	| actionAtomicRegex OP_STAR
	| actionAtomicRegex OP_PLUS
	| actionAtomicRegex CURLY_LEFT NUMBER, NUMBER CURLY_RIGHT
	;

production lookaheadRegex =
	actionAtomicRegex OP_FWDSLASH atomicRegex
	;

production actionAtomicRegex =
	PAR_LEFT actionAtomicRegex PAR_RIGHT
	| atomicRegex (OP_AT action OP_COLON IDENTIFIER)*
	;
	
production atomicRegex : rootRegex =
	PAR_LEFT disjunctiveRegex PAR_RIGHT
	| SQUARE_LEFT OP_CARET (STRING|regexRange)+ SQUARE_RIGHT
	| SQUARE_LEFT (STRING|regexRange)+ SQUARE_RIGHT
	| STRING
	| OP_DOT
	| OP_CARET
	| OP_DOLLAR
	| specifiedName
	;

production regexRange =
	STRING OP_DASH STRING
	;

production disjunctiveRegex =
	conjuctiveRegex (OP_OR conjuctiveRegex)*
	;

production conjunctiveRegex =
	rootRegex+
	;

production specifiedName =
	IDENTIFIER
	;

production operationalName =
	specifiedName (OP_AT action OP_COLON IDENTIFIER)
	;

production action =
	KW_SET
	| KW_UNSET
	| KW_FLAG
	| KW_UNFLAG
	| KW_APPEND
	| KW_PREPEND
	| KW_CLEAR
	| KW_LEFT_TRIM
	| KW_RIGHT_TRIM
	;