/*
	RECOGNIZED TOKENS:
		KW_TOKEN
		KW_REGEX
		KW_PRODUCTION
		KW_RULE
		KW_DETERMINISTIC
		KW_NONDETERMINISTIC
		KW_FINITE
		KW_AUTOMATON
		KW_PARSER
		KW_RECURSIVE_DESCENT
		KW_WITH
		KW_FOLLOWS
		KW_EXTENDS
		KW_INDIVIDUAL_STRING_LITERALS
		KW_GROUPED_STRING_LITERALS
		KW_TABLE_LOOKUP
		KW_MACHINE_LOOKUP
		KW_BACKTRACKING
		KW_PREDICTION

		IDENTIFIER
		NUMBER
		STRING

		OP_EQUALS
		OP_COLON
		OP_LEFTARR
		OP_SEMICOLON
		OP_DOT
		OP_CARET
		OP_DOLLAR
		SQUARE_LEFT
		SQUARE_RIGHT
		PAR_LEFT
		PAR_RIGHT
		CURLY_LEFT
		CURLY_RIGHT
		OP_STAR
		OP_PLUS
		OP_QM
		OP_OR
		OP_FWDSLASH,
		OP_COMMA
*/

production specification = 
	machineDefinitionList
	;

rule machineDefinitionList =
	machineDefinition*
	;

production machineDefinition =
	machineType IDENTIFIER (KW_WITH machineOptionList)? (KW_EXTENDS IDENTIFIER| KW_FOLLOWS IDENTIFIER)? CURLY_LEFT machineDefinitionBody CURLY_RIGHT
	;

rule machineOptionList =
	(KW_INDIVIDUAL_STRING_LITERALS
		| KW_GROUPED_STRING_LITERALS
		| KW_TABLE_LOOKUP
		| KW_MACHINE_LOOKUP
		| KW_BACKTRACKING
		| KW_PREDICTION)+
	;

production machineDefinitionBody =
	statementList
	;

rule statementList =
	statement statementList
	| statement
	;

production statement =
	tokenStatement
	| regexStatement
	;

production tokenStatement =
	KW_TOKEN declarationName OP_EQUALS statementBody 
	| KW_TOKEN declarationName COLON declarationNameList OP_EQUALS namedStatementBody
	| KW_TOKEN COLON declarationNameList OP_EQUALS statementBody
	;

production regexStatement =
	KW_REGEX declarationName OP_EQUALS namedStatementBody 
	| KW_REGEX declarationName COLON declarationNameList OP_EQUALS namedStatementBody
	| KW_REGEX COLON declarationNameList OP_EQUALS statementBody
	;

rule declarationName =
	IDENTIFIER
	;

rule declarationNameList =
	declarationName OP_COMMA declarationNameList
	| declarationName
	;

production namedStatementBody = 
	namedAlternativesList OP_SEMICOLON
	| OP_SEMICOLON
	;

rule namedAlternativesList =
	namedAlternative OP_OR namedAlternativesList
	| namedAlternative
	;

production namedAlternative = 
	regex
	| regex OP_COLON declarationNameList
	;

production alternative =
	namedAlternative
	| regex OP_LEFTARR declarationName
	| regex OP_LEFTARR declarationName OP_COLON declarationNameList
	;

rule alternativesList =
	alternative OP_OR alternativesList
	| alternative
	;

production qualifiedName = 
	qualifiedNameList
	;

rule qualifiedNameList = 
	IDENTIFIER OP_AMPERSAND qualifiedNameList
	| IDENTIFIER
	;

production regex =
	ESCAPED_CHAR
	| STRING
	| IDENTIFIER
	| OP_DOT
	| OP_CARET
	| OP_DOLLAR
	| SQUARE_LEFT STRING SQUARE_RIGHT
	| SQUARE_LEFT OP_CARET STRING SQUARE_RIGHT
	| regex OP_STAR
	| regex OP_PLUS
	| regex OP_QM
	| regex CURLY_LEFT NUMBER, NUMBER CURLY_RIGHT
	| regex regex
	| regex OP_OR regex
	| PAR_LEFT regex PAR_RIGHT
	| regex OP_FWDSLASH regex
	;