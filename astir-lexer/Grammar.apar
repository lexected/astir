/*
	RECOGNIZED TOKENS:
		KW_TOKEN
		KW_REGEX
		KW_PRODUCTION
		KW_RULE
		KW_DETERMINISTIC
		KW_NONDETERMINISTIC
		KW_FINITE
		KW_AUTOMATON
		KW_PARSER
		KW_RECURSIVE_DESCENT
		KW_WITH
		KW_FOLLOWS
		KW_EXTENDS
		KW_INDIVIDUAL_STRING_LITERALS
		KW_GROUPED_STRING_LITERALS
		KW_TABLE_LOOKUP
		KW_MACHINE_LOOKUP
		KW_BACKTRACKING
		KW_PREDICTION
		KW_CATEGORY

		IDENTIFIER
		NUMBER
		STRING

		OP_EQUALS
		OP_COLON
		OP_LEFTARR
		OP_SEMICOLON
		OP_DOT
		OP_CARET
		OP_DOLLAR
		SQUARE_LEFT
		SQUARE_RIGHT
		PAR_LEFT
		PAR_RIGHT
		CURLY_LEFT
		CURLY_RIGHT
		OP_STAR
		OP_PLUS
		OP_QM
		OP_OR
		OP_FWDSLASH,
		OP_COMMA,
		OP_AT
*/

production specification = 
	machineDefinitionList
	;

rule machineDefinitionList =
	machineDefinition*
	;

production machineDefinition =
	machineType IDENTIFIER (KW_WITH machineOptionList)? (KW_EXTENDS IDENTIFIER| KW_FOLLOWS IDENTIFIER)? OP_SEMICOLON
	| machineType IDENTIFIER (KW_WITH machineOptionList)? (KW_EXTENDS IDENTIFIER| KW_FOLLOWS IDENTIFIER)? CURLY_LEFT machineDefinitionBody CURLY_RIGHT
	;

rule machineOptionList =
	(KW_INDIVIDUAL_STRING_LITERALS
		| KW_GROUPED_STRING_LITERALS
		| KW_TABLE_LOOKUP
		| KW_MACHINE_LOOKUP
		| KW_BACKTRACKING
		| KW_PREDICTION)+
	;

production machineDefinitionBody =
	statementList
	;

rule statementList =
	statement*
	;

production statement =
	categoryStatement
	| grammarStatement
	;

production categoryStatement =
	KW_CATEGORY IDENTIFIER OP_EQUALS categoryStatementBody OP_SEMICOLON
	| KW_CATEGORY IDENTIFIER OP_COLON declarationNameList OP_EQUALS categoryStatementBody OP_SEMICOLON
	| KW_CATEGORY IDENTIFIER OP_COLON declarationNameList OP_SEMICOLON
	| KW_CATEGORY IDENTIFIER OP_SEMICOLON
	;

rule categoryStatementBody =
	qualifiedName*
	;

production qualifiedName =
	specializedName OP_AT identifier
	;

production grammarStatement =
	grammarStatementType IDENTIFIER OP_EQUALS grammarStatementBody OP_SEMICOLON
	| grammarStatementType IDENTIFIER OP_COLON declarationNameList OP_EQUALS grammarStatementBody OP_SEMICOLON
	;

rule grammarStatementType =
	KW_TOKEN
	| KW_REGEX
	| KW_RULE
	| KW_PRODUCTION
	;

rule declarationNameList =
	IDENTIFIER OP_COMMA declarationNameList
	| IDENTIFIER
	;

production grammarStatementBody = 
	alternative*
	;

production alternative = 
	qualifiedRegex*
	;

production qualifiedRegex =
	namableRegex (OP_AT IDENTIFIER)?
	;

production namableRegex =
	repetitiveRegex
	| lookaheadRegex
	| atomicRegex
	;

production repetitiveRegex =
	atomicRegex OP_STAR
	| atomicRegex OP_PLUS
	| atomicRegex CURLY_LEFT NUMBER, NUMBER CURLY_RIGHT
	| atomicRegex OP_QM
	;

production lookaheadRegex =
	atomicRegex OP_FWDSLASH namableRegex
	;

production atomicRegex : namableRegex =
	SQUARE_LEFT OP_CARET STRING+ SQUARE_RIGHT
	| SQUARE_LEFT OP_CARET regexRange+ SQUARE_RIGHT
	| SQUARE_LEFT STRING+ SQUARE_RIGHT
	| SQUARE_LEFT regexRange+ SQUARE_RIGHT
	| PAR_LEFT disjunctiveRegex PAR_RIGHT
	| STRING
	| specializedName
	| OP_DOT
	| OP_CARET
	| OP_DOLLAR
	;

production regexRange =
	STRING OP_DASH STRING
	;

production disjunctiveRegex =
	conjuctiveRegex+
	;

production conjunctiveRegex =
	namableRegex+
	;

production specializedName =
	IDENTIFIER (OP_AMPERSAND IDENTIFIER)*
	;