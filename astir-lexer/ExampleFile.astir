nondeterministic finite automaton ExampleTokenizer with individual_string_literals, table_lookup {
	regex digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";

	category number;

	token integer : number =
		digit+
		| "-" digit+@flag:negative
		;

	token decimal : number =
		"-"@flag:negative? digit+ "." digit+ ("e" integer)?
		;

	regex identifierStartingCharacter = ["a"-"z" "A"-"Z" "_"];
	regex identifierCharacter = identifierStartingCharacter | digit;

	token identifier = identifierStartingCharacter identifierCharacter*;

	token operator =
		"+"
		| "-"
		| "*"
		| "\"
		;
}

recursive_descent parser ExampleParser follows ExampleTokenizer {
	category declaration =
		identifier@name
	;

	production functionSpecification =
		keyword_function identifier@name "(" functionArgument*@parameters ")" ";" : declaration
		| keyword_function identifier@name "(" functionArgument*@parameters ")" "{" functionBodyStatement*@statements "}" : declaration, definition
		;
}