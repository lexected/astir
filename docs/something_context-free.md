# Something context-free

Regular languages are a strict subset of context-free free languages and thus, unfortunately, can not be represented by the conventional finite automata, although a properly generalized deterministic finite automaton can easily reach up to context-sensitive languages.

Most of the concepts presented in the [Something regular](/#something-regular) section, including but not being limited to categories, patterns, fields, actions, or terminality, are available in the entire languange and can hence naturally be used within machines other than the finite automata as well.

In this section we will therefore only focus on giving a minimal example of what is a context-free grammar for the traditional Lisp parenthesis nesting. Our parser machine of choice will be the LL(k) or more generally the LL(finite) parser. The LL(finite) parser can recognize (and indeed, parse) a relatively large subset of non-left-recursive context-free grammars., and will be sufficient for our purposes.

Suppose that we want to be able to parse Lisp trees like the following one

```lisp
(defun fibonacci (N)
  (if (or (zerop N) (= N 1))
      1
    (let
	((F1 (fibonacci (- N 1)))
	 (F2 (fibonacci (- N 2))))
      (+ F1 F2))))
```

Ignoring whitespace, the following could be our starting-point grammar

```astir
Node = 
    '(' ')'
    | '(' Node+ ')'
    | ['a'-'z' 'A'-'Z' '0'-'9' '_' '-' '+' '=']+
    ;
```

One could now easily proceed to define an LL(finite) (or, strictly speaking, an LL(2)) parser on raw input, if it weren't for the annoying whitespace that can just appear almost everywhere.

## The tokenizer
We shall instead tokenizer our raw input first, and then feed the terminal output of the tokenizer into an LL(finite) parser. Although simple, the following tokenizer will do the job

```astir
finite automaton TreeTokenizer {
    ignored root WhiteSpace = [' ' '\n' '\r' '\t']+;
    root PAR_LEFT = '(';
    root PAR_RIGHT = ')';
    root LEAF = ['a'-'z' 'A'-'Z' '_' '0' - '9']+;
}
```


## The parser machine
Equipped with `TreeTokenizer` the starting-point grammar can be rephrased as follows

```astir
LL(finite) parser TreeParser with ambiguity_resolved_by_precedence on TreeTokenizer {
    root category Node;

    production EmptyNode : Node = PAR_LEFT empty PAR_RIGHT;

    production BranchingNode : Node {
        Node list nodes;
    } = PAR_LEFT (Node@push:nodes)+ PAR_RIGHT;

    production Leaf : Node {
        raw text;
    } = LEAF@capture:text;
}
```

> More on the `ambiguity_resolved_by_precedence` machine attribute can be found below.

To generate output we invoke (Bash)

```bash
./astir TreeParsing.astir
```

or (Powershell)

```powershell
astir.exe TreeParsing.astir
```

Finally, the generated output can be lumped together into a parser with the following  `main.cpp` code

```cpp
#include "Output/TreeTokenizer.h"
#include "Output/TreeParser.h"

int main() {
	TextFileStream tfs("someInput.txt");

	TreeTokenizer::TreeTokenizer treeTokenizer;
	auto primaryStreamProcessed = treeTokenizer.processStreamWithIgnorance(tfs);

	ListProductionStream<TreeTokenizer::OutputProduction> lps(primaryStreamProcessed);

	TreeParser::TreeParser treeParser;
	auto secondaryStreamProcessed = treeParser.parse(lps);

	return 0;
}
```

> Remember to compile the boilerplate `.cpp` files as well in order to be able to link the intermediate output successfully.

## LL(k) vs LL(finite) - so what is the difference?

## Limitations of LL(finite) parsers

### Left-recursion
The following grammar is clearly left-recursive

```astir
production Expression {
    flag isUnary;
    Expression item lhs;
    Expression item rhs;
} = 
    Expression@set:lhs '+' Expression@set:rhs
    | Variable@flag:isUnary@set:lhs
    | Constant@flag:isUnary@set:lhs
    ;
```

There are, however, ways of systematically eliminating left-recursion, even if it involves cycles and epsilon-productions (empty productions). So, the constraint on the input grammars to be non-left-recursive actually isn't that prohibitive. Furthermore, patterns can make sure that all the productions that would have otherwise been clearly generic can actually be made to look natural, at least on the generated output.

### Ambiguity

Talk about non-decidability of ambiguity detection and the `ambiguity_resolved_by_precedence` attribute.

### General non-LL(finite)-ness
Take a look at the following astir grammar

```astir
LL(finite) parser TreeParser with ambiguity_resolved_by_precedence {
	root production Node =
		'(' Node ')'
		| '(' Node Node ')'
		| 'L' // as in "leaf"
		;
}
```

Although one could be tempted to say that it is ambiguous, it is not, and that is not the reason why asking astir to generate parser files will lead to errorneous behaviour. The real problem is that the grammar is not LL(finite) - while a recursive parser that attempts to match productions one-by-one and backtracks if not successful could parse exactly the language generated by this grammar, the LL(finite) parsers are not quite so powerful. Regardless of what finite lookahead is chosen, the parser generated will not be able to distinguish between the first and second alternatives' lookaheads for any prefix of length strictly greater than `1`. An LL parser with a finite automaton on lookahead, (e.g. an LL(*) parser) would work.