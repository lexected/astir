#pragma once

#include <sstream>

#include "${{MachineName}}.h"

namespace ${{MachineName}} {
	std::shared_ptr<OutputProduction> ${{MachineName}}::apply(InputStream& rs) {
		try {
			m_lastApplicationSuccessful = true;
			return parse_root(rs);
		} catch(const Exception& ex) {
			m_lastException = std::make_unique<Exception>(ex);
			m_lastApplicationSuccessful = false;
			return nullptr;
		}
	}

	std::shared_ptr<OutputProduction> ${{MachineName}}::parse(InputStream& rs) {
		return parse_root(rs);
	}

	std::shared_ptr<OutputProduction> ${{MachineName}}::parseWithIgnorance(InputStream& rs) {
		while(rs.good()) {
			auto ret = parse(rs);
			if(ret) {
				return ret;
			}
		}

		throw Exception("Parse with ignorance so far unsuccessful but the input stream is no longer good()");
		return nullptr;
	}

	std::list<std::shared_ptr<OutputProduction>> ${{MachineName}}::parseStream(InputStream& rs) {
		std::list<std::shared_ptr<OutputProduction>> ret;

		while(rs.good()) {
			auto p = parse(rs);
			ret.push_back(p);
		}

		return ret;
	}

	std::list<std::shared_ptr<OutputProduction>> ${{MachineName}}::parseStreamWithIgnorance(InputStream& rs) {
		std::list<std::shared_ptr<OutputProduction>> ret;

		while(rs.good()) {
			auto p = parse(rs);
			if(p) {
				ret.push_back(p);
			}
		}

		return ret;
	}

	void ${{MachineName}}::reset() {
		m_lastApplicationSuccessful = false;
	}
	
	std::string ${{MachineName}}::lastError() const {
		if(m_lastException) {
			return m_lastException->what();
		} else {
			return "";
		}
	}

	void ${{MachineName}}::error(const std::string& message) const {
		throw Exception(message);
	}

	${{ParsingDefinitions}}
	// helper methods
	${{CombineRawDefinition}}
}